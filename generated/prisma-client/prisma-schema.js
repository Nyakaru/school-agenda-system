module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.34.12). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateClassroom {
  count: Int!
}

type AggregateCountry {
  count: Int!
}

type AggregateRegion {
  count: Int!
}

type AggregateSchool {
  count: Int!
}

type AggregateStudent {
  count: Int!
}

type AggregateSubject {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Classroom {
  id: ID!
  name: String!
  level: String!
  school: School!
  classTeacher: User
  students(where: StudentWhereInput, orderBy: StudentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Student!]
  subjects(where: SubjectWhereInput, orderBy: SubjectOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Subject!]
  createdAt: DateTime
  updatedAt: DateTime
}

type ClassroomConnection {
  pageInfo: PageInfo!
  edges: [ClassroomEdge]!
  aggregate: AggregateClassroom!
}

input ClassroomCreateInput {
  id: ID
  name: String!
  level: String!
  school: SchoolCreateOneInput!
  classTeacher: UserCreateOneInput
  students: StudentCreateManyWithoutClassInput
  subjects: SubjectCreateManyWithoutClassInput
}

input ClassroomCreateOneWithoutStudentsInput {
  create: ClassroomCreateWithoutStudentsInput
  connect: ClassroomWhereUniqueInput
}

input ClassroomCreateOneWithoutSubjectsInput {
  create: ClassroomCreateWithoutSubjectsInput
  connect: ClassroomWhereUniqueInput
}

input ClassroomCreateWithoutStudentsInput {
  id: ID
  name: String!
  level: String!
  school: SchoolCreateOneInput!
  classTeacher: UserCreateOneInput
  subjects: SubjectCreateManyWithoutClassInput
}

input ClassroomCreateWithoutSubjectsInput {
  id: ID
  name: String!
  level: String!
  school: SchoolCreateOneInput!
  classTeacher: UserCreateOneInput
  students: StudentCreateManyWithoutClassInput
}

type ClassroomEdge {
  node: Classroom!
  cursor: String!
}

enum ClassroomOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  level_ASC
  level_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ClassroomPreviousValues {
  id: ID!
  name: String!
  level: String!
  createdAt: DateTime
  updatedAt: DateTime
}

type ClassroomSubscriptionPayload {
  mutation: MutationType!
  node: Classroom
  updatedFields: [String!]
  previousValues: ClassroomPreviousValues
}

input ClassroomSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ClassroomWhereInput
  AND: [ClassroomSubscriptionWhereInput!]
  OR: [ClassroomSubscriptionWhereInput!]
  NOT: [ClassroomSubscriptionWhereInput!]
}

input ClassroomUpdateInput {
  name: String
  level: String
  school: SchoolUpdateOneRequiredInput
  classTeacher: UserUpdateOneInput
  students: StudentUpdateManyWithoutClassInput
  subjects: SubjectUpdateManyWithoutClassInput
}

input ClassroomUpdateManyMutationInput {
  name: String
  level: String
}

input ClassroomUpdateOneRequiredWithoutSubjectsInput {
  create: ClassroomCreateWithoutSubjectsInput
  update: ClassroomUpdateWithoutSubjectsDataInput
  upsert: ClassroomUpsertWithoutSubjectsInput
  connect: ClassroomWhereUniqueInput
}

input ClassroomUpdateOneWithoutStudentsInput {
  create: ClassroomCreateWithoutStudentsInput
  update: ClassroomUpdateWithoutStudentsDataInput
  upsert: ClassroomUpsertWithoutStudentsInput
  delete: Boolean
  disconnect: Boolean
  connect: ClassroomWhereUniqueInput
}

input ClassroomUpdateWithoutStudentsDataInput {
  name: String
  level: String
  school: SchoolUpdateOneRequiredInput
  classTeacher: UserUpdateOneInput
  subjects: SubjectUpdateManyWithoutClassInput
}

input ClassroomUpdateWithoutSubjectsDataInput {
  name: String
  level: String
  school: SchoolUpdateOneRequiredInput
  classTeacher: UserUpdateOneInput
  students: StudentUpdateManyWithoutClassInput
}

input ClassroomUpsertWithoutStudentsInput {
  update: ClassroomUpdateWithoutStudentsDataInput!
  create: ClassroomCreateWithoutStudentsInput!
}

input ClassroomUpsertWithoutSubjectsInput {
  update: ClassroomUpdateWithoutSubjectsDataInput!
  create: ClassroomCreateWithoutSubjectsInput!
}

input ClassroomWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  level: String
  level_not: String
  level_in: [String!]
  level_not_in: [String!]
  level_lt: String
  level_lte: String
  level_gt: String
  level_gte: String
  level_contains: String
  level_not_contains: String
  level_starts_with: String
  level_not_starts_with: String
  level_ends_with: String
  level_not_ends_with: String
  school: SchoolWhereInput
  classTeacher: UserWhereInput
  students_every: StudentWhereInput
  students_some: StudentWhereInput
  students_none: StudentWhereInput
  subjects_every: SubjectWhereInput
  subjects_some: SubjectWhereInput
  subjects_none: SubjectWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ClassroomWhereInput!]
  OR: [ClassroomWhereInput!]
  NOT: [ClassroomWhereInput!]
}

input ClassroomWhereUniqueInput {
  id: ID
}

type Country {
  id: ID!
  name: String!
  createdAt: DateTime
  updatedAt: DateTime
}

type CountryConnection {
  pageInfo: PageInfo!
  edges: [CountryEdge]!
  aggregate: AggregateCountry!
}

input CountryCreateInput {
  id: ID
  name: String!
}

input CountryCreateOneInput {
  create: CountryCreateInput
  connect: CountryWhereUniqueInput
}

type CountryEdge {
  node: Country!
  cursor: String!
}

enum CountryOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type CountryPreviousValues {
  id: ID!
  name: String!
  createdAt: DateTime
  updatedAt: DateTime
}

type CountrySubscriptionPayload {
  mutation: MutationType!
  node: Country
  updatedFields: [String!]
  previousValues: CountryPreviousValues
}

input CountrySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CountryWhereInput
  AND: [CountrySubscriptionWhereInput!]
  OR: [CountrySubscriptionWhereInput!]
  NOT: [CountrySubscriptionWhereInput!]
}

input CountryUpdateDataInput {
  name: String
}

input CountryUpdateInput {
  name: String
}

input CountryUpdateManyMutationInput {
  name: String
}

input CountryUpdateOneInput {
  create: CountryCreateInput
  update: CountryUpdateDataInput
  upsert: CountryUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: CountryWhereUniqueInput
}

input CountryUpsertNestedInput {
  update: CountryUpdateDataInput!
  create: CountryCreateInput!
}

input CountryWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [CountryWhereInput!]
  OR: [CountryWhereInput!]
  NOT: [CountryWhereInput!]
}

input CountryWhereUniqueInput {
  id: ID
}

scalar DateTime

enum Level {
  PRESCHOOL
  PRIMARY
  HIGHSCHOOL
  GENERAL
}

scalar Long

type Mutation {
  createClassroom(data: ClassroomCreateInput!): Classroom!
  updateClassroom(data: ClassroomUpdateInput!, where: ClassroomWhereUniqueInput!): Classroom
  updateManyClassrooms(data: ClassroomUpdateManyMutationInput!, where: ClassroomWhereInput): BatchPayload!
  upsertClassroom(where: ClassroomWhereUniqueInput!, create: ClassroomCreateInput!, update: ClassroomUpdateInput!): Classroom!
  deleteClassroom(where: ClassroomWhereUniqueInput!): Classroom
  deleteManyClassrooms(where: ClassroomWhereInput): BatchPayload!
  createCountry(data: CountryCreateInput!): Country!
  updateCountry(data: CountryUpdateInput!, where: CountryWhereUniqueInput!): Country
  updateManyCountries(data: CountryUpdateManyMutationInput!, where: CountryWhereInput): BatchPayload!
  upsertCountry(where: CountryWhereUniqueInput!, create: CountryCreateInput!, update: CountryUpdateInput!): Country!
  deleteCountry(where: CountryWhereUniqueInput!): Country
  deleteManyCountries(where: CountryWhereInput): BatchPayload!
  createRegion(data: RegionCreateInput!): Region!
  updateRegion(data: RegionUpdateInput!, where: RegionWhereUniqueInput!): Region
  updateManyRegions(data: RegionUpdateManyMutationInput!, where: RegionWhereInput): BatchPayload!
  upsertRegion(where: RegionWhereUniqueInput!, create: RegionCreateInput!, update: RegionUpdateInput!): Region!
  deleteRegion(where: RegionWhereUniqueInput!): Region
  deleteManyRegions(where: RegionWhereInput): BatchPayload!
  createSchool(data: SchoolCreateInput!): School!
  updateSchool(data: SchoolUpdateInput!, where: SchoolWhereUniqueInput!): School
  updateManySchools(data: SchoolUpdateManyMutationInput!, where: SchoolWhereInput): BatchPayload!
  upsertSchool(where: SchoolWhereUniqueInput!, create: SchoolCreateInput!, update: SchoolUpdateInput!): School!
  deleteSchool(where: SchoolWhereUniqueInput!): School
  deleteManySchools(where: SchoolWhereInput): BatchPayload!
  createStudent(data: StudentCreateInput!): Student!
  updateStudent(data: StudentUpdateInput!, where: StudentWhereUniqueInput!): Student
  updateManyStudents(data: StudentUpdateManyMutationInput!, where: StudentWhereInput): BatchPayload!
  upsertStudent(where: StudentWhereUniqueInput!, create: StudentCreateInput!, update: StudentUpdateInput!): Student!
  deleteStudent(where: StudentWhereUniqueInput!): Student
  deleteManyStudents(where: StudentWhereInput): BatchPayload!
  createSubject(data: SubjectCreateInput!): Subject!
  updateSubject(data: SubjectUpdateInput!, where: SubjectWhereUniqueInput!): Subject
  updateManySubjects(data: SubjectUpdateManyMutationInput!, where: SubjectWhereInput): BatchPayload!
  upsertSubject(where: SubjectWhereUniqueInput!, create: SubjectCreateInput!, update: SubjectUpdateInput!): Subject!
  deleteSubject(where: SubjectWhereUniqueInput!): Subject
  deleteManySubjects(where: SubjectWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  classroom(where: ClassroomWhereUniqueInput!): Classroom
  classrooms(where: ClassroomWhereInput, orderBy: ClassroomOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Classroom]!
  classroomsConnection(where: ClassroomWhereInput, orderBy: ClassroomOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ClassroomConnection!
  country(where: CountryWhereUniqueInput!): Country
  countries(where: CountryWhereInput, orderBy: CountryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Country]!
  countriesConnection(where: CountryWhereInput, orderBy: CountryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CountryConnection!
  region(where: RegionWhereUniqueInput!): Region
  regions(where: RegionWhereInput, orderBy: RegionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Region]!
  regionsConnection(where: RegionWhereInput, orderBy: RegionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): RegionConnection!
  school(where: SchoolWhereUniqueInput!): School
  schools(where: SchoolWhereInput, orderBy: SchoolOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [School]!
  schoolsConnection(where: SchoolWhereInput, orderBy: SchoolOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SchoolConnection!
  student(where: StudentWhereUniqueInput!): Student
  students(where: StudentWhereInput, orderBy: StudentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Student]!
  studentsConnection(where: StudentWhereInput, orderBy: StudentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): StudentConnection!
  subject(where: SubjectWhereUniqueInput!): Subject
  subjects(where: SubjectWhereInput, orderBy: SubjectOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Subject]!
  subjectsConnection(where: SubjectWhereInput, orderBy: SubjectOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SubjectConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

type Region {
  id: ID!
  name: String!
  country: Country
  createdAt: DateTime
  updatedAt: DateTime
}

type RegionConnection {
  pageInfo: PageInfo!
  edges: [RegionEdge]!
  aggregate: AggregateRegion!
}

input RegionCreateInput {
  id: ID
  name: String!
  country: CountryCreateOneInput
}

input RegionCreateOneInput {
  create: RegionCreateInput
  connect: RegionWhereUniqueInput
}

type RegionEdge {
  node: Region!
  cursor: String!
}

enum RegionOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type RegionPreviousValues {
  id: ID!
  name: String!
  createdAt: DateTime
  updatedAt: DateTime
}

type RegionSubscriptionPayload {
  mutation: MutationType!
  node: Region
  updatedFields: [String!]
  previousValues: RegionPreviousValues
}

input RegionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: RegionWhereInput
  AND: [RegionSubscriptionWhereInput!]
  OR: [RegionSubscriptionWhereInput!]
  NOT: [RegionSubscriptionWhereInput!]
}

input RegionUpdateDataInput {
  name: String
  country: CountryUpdateOneInput
}

input RegionUpdateInput {
  name: String
  country: CountryUpdateOneInput
}

input RegionUpdateManyMutationInput {
  name: String
}

input RegionUpdateOneInput {
  create: RegionCreateInput
  update: RegionUpdateDataInput
  upsert: RegionUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: RegionWhereUniqueInput
}

input RegionUpsertNestedInput {
  update: RegionUpdateDataInput!
  create: RegionCreateInput!
}

input RegionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  country: CountryWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [RegionWhereInput!]
  OR: [RegionWhereInput!]
  NOT: [RegionWhereInput!]
}

input RegionWhereUniqueInput {
  id: ID
}

enum Role {
  SUDO
  ADMIN
  TEACHER
  PARENT
  ACCOUNTANT
  STOREMAN
  USER
}

type School {
  id: ID!
  name: String!
  region: Region
  address: String
  email: String
  phone: String!
  schoolCode: String!
  imageUrl: String
  level: Level!
  students(where: StudentWhereInput, orderBy: StudentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Student!]
  createdAt: DateTime
  updatedAt: DateTime
}

type SchoolConnection {
  pageInfo: PageInfo!
  edges: [SchoolEdge]!
  aggregate: AggregateSchool!
}

input SchoolCreateInput {
  id: ID
  name: String!
  region: RegionCreateOneInput
  address: String
  email: String
  phone: String!
  schoolCode: String!
  imageUrl: String
  level: Level
  students: StudentCreateManyWithoutSchoolInput
}

input SchoolCreateOneInput {
  create: SchoolCreateInput
  connect: SchoolWhereUniqueInput
}

input SchoolCreateOneWithoutStudentsInput {
  create: SchoolCreateWithoutStudentsInput
  connect: SchoolWhereUniqueInput
}

input SchoolCreateWithoutStudentsInput {
  id: ID
  name: String!
  region: RegionCreateOneInput
  address: String
  email: String
  phone: String!
  schoolCode: String!
  imageUrl: String
  level: Level
}

type SchoolEdge {
  node: School!
  cursor: String!
}

enum SchoolOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  address_ASC
  address_DESC
  email_ASC
  email_DESC
  phone_ASC
  phone_DESC
  schoolCode_ASC
  schoolCode_DESC
  imageUrl_ASC
  imageUrl_DESC
  level_ASC
  level_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type SchoolPreviousValues {
  id: ID!
  name: String!
  address: String
  email: String
  phone: String!
  schoolCode: String!
  imageUrl: String
  level: Level!
  createdAt: DateTime
  updatedAt: DateTime
}

type SchoolSubscriptionPayload {
  mutation: MutationType!
  node: School
  updatedFields: [String!]
  previousValues: SchoolPreviousValues
}

input SchoolSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SchoolWhereInput
  AND: [SchoolSubscriptionWhereInput!]
  OR: [SchoolSubscriptionWhereInput!]
  NOT: [SchoolSubscriptionWhereInput!]
}

input SchoolUpdateDataInput {
  name: String
  region: RegionUpdateOneInput
  address: String
  email: String
  phone: String
  schoolCode: String
  imageUrl: String
  level: Level
  students: StudentUpdateManyWithoutSchoolInput
}

input SchoolUpdateInput {
  name: String
  region: RegionUpdateOneInput
  address: String
  email: String
  phone: String
  schoolCode: String
  imageUrl: String
  level: Level
  students: StudentUpdateManyWithoutSchoolInput
}

input SchoolUpdateManyMutationInput {
  name: String
  address: String
  email: String
  phone: String
  schoolCode: String
  imageUrl: String
  level: Level
}

input SchoolUpdateOneInput {
  create: SchoolCreateInput
  update: SchoolUpdateDataInput
  upsert: SchoolUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: SchoolWhereUniqueInput
}

input SchoolUpdateOneRequiredInput {
  create: SchoolCreateInput
  update: SchoolUpdateDataInput
  upsert: SchoolUpsertNestedInput
  connect: SchoolWhereUniqueInput
}

input SchoolUpdateOneRequiredWithoutStudentsInput {
  create: SchoolCreateWithoutStudentsInput
  update: SchoolUpdateWithoutStudentsDataInput
  upsert: SchoolUpsertWithoutStudentsInput
  connect: SchoolWhereUniqueInput
}

input SchoolUpdateWithoutStudentsDataInput {
  name: String
  region: RegionUpdateOneInput
  address: String
  email: String
  phone: String
  schoolCode: String
  imageUrl: String
  level: Level
}

input SchoolUpsertNestedInput {
  update: SchoolUpdateDataInput!
  create: SchoolCreateInput!
}

input SchoolUpsertWithoutStudentsInput {
  update: SchoolUpdateWithoutStudentsDataInput!
  create: SchoolCreateWithoutStudentsInput!
}

input SchoolWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  region: RegionWhereInput
  address: String
  address_not: String
  address_in: [String!]
  address_not_in: [String!]
  address_lt: String
  address_lte: String
  address_gt: String
  address_gte: String
  address_contains: String
  address_not_contains: String
  address_starts_with: String
  address_not_starts_with: String
  address_ends_with: String
  address_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  phone: String
  phone_not: String
  phone_in: [String!]
  phone_not_in: [String!]
  phone_lt: String
  phone_lte: String
  phone_gt: String
  phone_gte: String
  phone_contains: String
  phone_not_contains: String
  phone_starts_with: String
  phone_not_starts_with: String
  phone_ends_with: String
  phone_not_ends_with: String
  schoolCode: String
  schoolCode_not: String
  schoolCode_in: [String!]
  schoolCode_not_in: [String!]
  schoolCode_lt: String
  schoolCode_lte: String
  schoolCode_gt: String
  schoolCode_gte: String
  schoolCode_contains: String
  schoolCode_not_contains: String
  schoolCode_starts_with: String
  schoolCode_not_starts_with: String
  schoolCode_ends_with: String
  schoolCode_not_ends_with: String
  imageUrl: String
  imageUrl_not: String
  imageUrl_in: [String!]
  imageUrl_not_in: [String!]
  imageUrl_lt: String
  imageUrl_lte: String
  imageUrl_gt: String
  imageUrl_gte: String
  imageUrl_contains: String
  imageUrl_not_contains: String
  imageUrl_starts_with: String
  imageUrl_not_starts_with: String
  imageUrl_ends_with: String
  imageUrl_not_ends_with: String
  level: Level
  level_not: Level
  level_in: [Level!]
  level_not_in: [Level!]
  students_every: StudentWhereInput
  students_some: StudentWhereInput
  students_none: StudentWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [SchoolWhereInput!]
  OR: [SchoolWhereInput!]
  NOT: [SchoolWhereInput!]
}

input SchoolWhereUniqueInput {
  id: ID
  phone: String
  schoolCode: String
}

type Student {
  id: ID!
  name: String!
  admNo: String!
  domitory: String
  class: Classroom
  feeBalance: String
  subjects(where: SubjectWhereInput, orderBy: SubjectOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Subject!]
  school: School!
  createdAt: DateTime
  updatedAt: DateTime
}

type StudentConnection {
  pageInfo: PageInfo!
  edges: [StudentEdge]!
  aggregate: AggregateStudent!
}

input StudentCreateInput {
  id: ID
  name: String!
  admNo: String!
  domitory: String
  class: ClassroomCreateOneWithoutStudentsInput
  feeBalance: String
  subjects: SubjectCreateManyInput
  school: SchoolCreateOneWithoutStudentsInput!
}

input StudentCreateManyWithoutClassInput {
  create: [StudentCreateWithoutClassInput!]
  connect: [StudentWhereUniqueInput!]
}

input StudentCreateManyWithoutSchoolInput {
  create: [StudentCreateWithoutSchoolInput!]
  connect: [StudentWhereUniqueInput!]
}

input StudentCreateWithoutClassInput {
  id: ID
  name: String!
  admNo: String!
  domitory: String
  feeBalance: String
  subjects: SubjectCreateManyInput
  school: SchoolCreateOneWithoutStudentsInput!
}

input StudentCreateWithoutSchoolInput {
  id: ID
  name: String!
  admNo: String!
  domitory: String
  class: ClassroomCreateOneWithoutStudentsInput
  feeBalance: String
  subjects: SubjectCreateManyInput
}

type StudentEdge {
  node: Student!
  cursor: String!
}

enum StudentOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  admNo_ASC
  admNo_DESC
  domitory_ASC
  domitory_DESC
  feeBalance_ASC
  feeBalance_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type StudentPreviousValues {
  id: ID!
  name: String!
  admNo: String!
  domitory: String
  feeBalance: String
  createdAt: DateTime
  updatedAt: DateTime
}

input StudentScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  admNo: String
  admNo_not: String
  admNo_in: [String!]
  admNo_not_in: [String!]
  admNo_lt: String
  admNo_lte: String
  admNo_gt: String
  admNo_gte: String
  admNo_contains: String
  admNo_not_contains: String
  admNo_starts_with: String
  admNo_not_starts_with: String
  admNo_ends_with: String
  admNo_not_ends_with: String
  domitory: String
  domitory_not: String
  domitory_in: [String!]
  domitory_not_in: [String!]
  domitory_lt: String
  domitory_lte: String
  domitory_gt: String
  domitory_gte: String
  domitory_contains: String
  domitory_not_contains: String
  domitory_starts_with: String
  domitory_not_starts_with: String
  domitory_ends_with: String
  domitory_not_ends_with: String
  feeBalance: String
  feeBalance_not: String
  feeBalance_in: [String!]
  feeBalance_not_in: [String!]
  feeBalance_lt: String
  feeBalance_lte: String
  feeBalance_gt: String
  feeBalance_gte: String
  feeBalance_contains: String
  feeBalance_not_contains: String
  feeBalance_starts_with: String
  feeBalance_not_starts_with: String
  feeBalance_ends_with: String
  feeBalance_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [StudentScalarWhereInput!]
  OR: [StudentScalarWhereInput!]
  NOT: [StudentScalarWhereInput!]
}

type StudentSubscriptionPayload {
  mutation: MutationType!
  node: Student
  updatedFields: [String!]
  previousValues: StudentPreviousValues
}

input StudentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: StudentWhereInput
  AND: [StudentSubscriptionWhereInput!]
  OR: [StudentSubscriptionWhereInput!]
  NOT: [StudentSubscriptionWhereInput!]
}

input StudentUpdateInput {
  name: String
  admNo: String
  domitory: String
  class: ClassroomUpdateOneWithoutStudentsInput
  feeBalance: String
  subjects: SubjectUpdateManyInput
  school: SchoolUpdateOneRequiredWithoutStudentsInput
}

input StudentUpdateManyDataInput {
  name: String
  admNo: String
  domitory: String
  feeBalance: String
}

input StudentUpdateManyMutationInput {
  name: String
  admNo: String
  domitory: String
  feeBalance: String
}

input StudentUpdateManyWithoutClassInput {
  create: [StudentCreateWithoutClassInput!]
  delete: [StudentWhereUniqueInput!]
  connect: [StudentWhereUniqueInput!]
  set: [StudentWhereUniqueInput!]
  disconnect: [StudentWhereUniqueInput!]
  update: [StudentUpdateWithWhereUniqueWithoutClassInput!]
  upsert: [StudentUpsertWithWhereUniqueWithoutClassInput!]
  deleteMany: [StudentScalarWhereInput!]
  updateMany: [StudentUpdateManyWithWhereNestedInput!]
}

input StudentUpdateManyWithoutSchoolInput {
  create: [StudentCreateWithoutSchoolInput!]
  delete: [StudentWhereUniqueInput!]
  connect: [StudentWhereUniqueInput!]
  set: [StudentWhereUniqueInput!]
  disconnect: [StudentWhereUniqueInput!]
  update: [StudentUpdateWithWhereUniqueWithoutSchoolInput!]
  upsert: [StudentUpsertWithWhereUniqueWithoutSchoolInput!]
  deleteMany: [StudentScalarWhereInput!]
  updateMany: [StudentUpdateManyWithWhereNestedInput!]
}

input StudentUpdateManyWithWhereNestedInput {
  where: StudentScalarWhereInput!
  data: StudentUpdateManyDataInput!
}

input StudentUpdateWithoutClassDataInput {
  name: String
  admNo: String
  domitory: String
  feeBalance: String
  subjects: SubjectUpdateManyInput
  school: SchoolUpdateOneRequiredWithoutStudentsInput
}

input StudentUpdateWithoutSchoolDataInput {
  name: String
  admNo: String
  domitory: String
  class: ClassroomUpdateOneWithoutStudentsInput
  feeBalance: String
  subjects: SubjectUpdateManyInput
}

input StudentUpdateWithWhereUniqueWithoutClassInput {
  where: StudentWhereUniqueInput!
  data: StudentUpdateWithoutClassDataInput!
}

input StudentUpdateWithWhereUniqueWithoutSchoolInput {
  where: StudentWhereUniqueInput!
  data: StudentUpdateWithoutSchoolDataInput!
}

input StudentUpsertWithWhereUniqueWithoutClassInput {
  where: StudentWhereUniqueInput!
  update: StudentUpdateWithoutClassDataInput!
  create: StudentCreateWithoutClassInput!
}

input StudentUpsertWithWhereUniqueWithoutSchoolInput {
  where: StudentWhereUniqueInput!
  update: StudentUpdateWithoutSchoolDataInput!
  create: StudentCreateWithoutSchoolInput!
}

input StudentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  admNo: String
  admNo_not: String
  admNo_in: [String!]
  admNo_not_in: [String!]
  admNo_lt: String
  admNo_lte: String
  admNo_gt: String
  admNo_gte: String
  admNo_contains: String
  admNo_not_contains: String
  admNo_starts_with: String
  admNo_not_starts_with: String
  admNo_ends_with: String
  admNo_not_ends_with: String
  domitory: String
  domitory_not: String
  domitory_in: [String!]
  domitory_not_in: [String!]
  domitory_lt: String
  domitory_lte: String
  domitory_gt: String
  domitory_gte: String
  domitory_contains: String
  domitory_not_contains: String
  domitory_starts_with: String
  domitory_not_starts_with: String
  domitory_ends_with: String
  domitory_not_ends_with: String
  class: ClassroomWhereInput
  feeBalance: String
  feeBalance_not: String
  feeBalance_in: [String!]
  feeBalance_not_in: [String!]
  feeBalance_lt: String
  feeBalance_lte: String
  feeBalance_gt: String
  feeBalance_gte: String
  feeBalance_contains: String
  feeBalance_not_contains: String
  feeBalance_starts_with: String
  feeBalance_not_starts_with: String
  feeBalance_ends_with: String
  feeBalance_not_ends_with: String
  subjects_every: SubjectWhereInput
  subjects_some: SubjectWhereInput
  subjects_none: SubjectWhereInput
  school: SchoolWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [StudentWhereInput!]
  OR: [StudentWhereInput!]
  NOT: [StudentWhereInput!]
}

input StudentWhereUniqueInput {
  id: ID
}

type Subject {
  id: ID!
  name: String!
  assignee: User
  class: Classroom!
  createdAt: DateTime
  updatedAt: DateTime
}

type SubjectConnection {
  pageInfo: PageInfo!
  edges: [SubjectEdge]!
  aggregate: AggregateSubject!
}

input SubjectCreateInput {
  id: ID
  name: String!
  assignee: UserCreateOneInput
  class: ClassroomCreateOneWithoutSubjectsInput!
}

input SubjectCreateManyInput {
  create: [SubjectCreateInput!]
  connect: [SubjectWhereUniqueInput!]
}

input SubjectCreateManyWithoutClassInput {
  create: [SubjectCreateWithoutClassInput!]
  connect: [SubjectWhereUniqueInput!]
}

input SubjectCreateWithoutClassInput {
  id: ID
  name: String!
  assignee: UserCreateOneInput
}

type SubjectEdge {
  node: Subject!
  cursor: String!
}

enum SubjectOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type SubjectPreviousValues {
  id: ID!
  name: String!
  createdAt: DateTime
  updatedAt: DateTime
}

input SubjectScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [SubjectScalarWhereInput!]
  OR: [SubjectScalarWhereInput!]
  NOT: [SubjectScalarWhereInput!]
}

type SubjectSubscriptionPayload {
  mutation: MutationType!
  node: Subject
  updatedFields: [String!]
  previousValues: SubjectPreviousValues
}

input SubjectSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SubjectWhereInput
  AND: [SubjectSubscriptionWhereInput!]
  OR: [SubjectSubscriptionWhereInput!]
  NOT: [SubjectSubscriptionWhereInput!]
}

input SubjectUpdateDataInput {
  name: String
  assignee: UserUpdateOneInput
  class: ClassroomUpdateOneRequiredWithoutSubjectsInput
}

input SubjectUpdateInput {
  name: String
  assignee: UserUpdateOneInput
  class: ClassroomUpdateOneRequiredWithoutSubjectsInput
}

input SubjectUpdateManyDataInput {
  name: String
}

input SubjectUpdateManyInput {
  create: [SubjectCreateInput!]
  update: [SubjectUpdateWithWhereUniqueNestedInput!]
  upsert: [SubjectUpsertWithWhereUniqueNestedInput!]
  delete: [SubjectWhereUniqueInput!]
  connect: [SubjectWhereUniqueInput!]
  set: [SubjectWhereUniqueInput!]
  disconnect: [SubjectWhereUniqueInput!]
  deleteMany: [SubjectScalarWhereInput!]
  updateMany: [SubjectUpdateManyWithWhereNestedInput!]
}

input SubjectUpdateManyMutationInput {
  name: String
}

input SubjectUpdateManyWithoutClassInput {
  create: [SubjectCreateWithoutClassInput!]
  delete: [SubjectWhereUniqueInput!]
  connect: [SubjectWhereUniqueInput!]
  set: [SubjectWhereUniqueInput!]
  disconnect: [SubjectWhereUniqueInput!]
  update: [SubjectUpdateWithWhereUniqueWithoutClassInput!]
  upsert: [SubjectUpsertWithWhereUniqueWithoutClassInput!]
  deleteMany: [SubjectScalarWhereInput!]
  updateMany: [SubjectUpdateManyWithWhereNestedInput!]
}

input SubjectUpdateManyWithWhereNestedInput {
  where: SubjectScalarWhereInput!
  data: SubjectUpdateManyDataInput!
}

input SubjectUpdateWithoutClassDataInput {
  name: String
  assignee: UserUpdateOneInput
}

input SubjectUpdateWithWhereUniqueNestedInput {
  where: SubjectWhereUniqueInput!
  data: SubjectUpdateDataInput!
}

input SubjectUpdateWithWhereUniqueWithoutClassInput {
  where: SubjectWhereUniqueInput!
  data: SubjectUpdateWithoutClassDataInput!
}

input SubjectUpsertWithWhereUniqueNestedInput {
  where: SubjectWhereUniqueInput!
  update: SubjectUpdateDataInput!
  create: SubjectCreateInput!
}

input SubjectUpsertWithWhereUniqueWithoutClassInput {
  where: SubjectWhereUniqueInput!
  update: SubjectUpdateWithoutClassDataInput!
  create: SubjectCreateWithoutClassInput!
}

input SubjectWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  assignee: UserWhereInput
  class: ClassroomWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [SubjectWhereInput!]
  OR: [SubjectWhereInput!]
  NOT: [SubjectWhereInput!]
}

input SubjectWhereUniqueInput {
  id: ID
}

type Subscription {
  classroom(where: ClassroomSubscriptionWhereInput): ClassroomSubscriptionPayload
  country(where: CountrySubscriptionWhereInput): CountrySubscriptionPayload
  region(where: RegionSubscriptionWhereInput): RegionSubscriptionPayload
  school(where: SchoolSubscriptionWhereInput): SchoolSubscriptionPayload
  student(where: StudentSubscriptionWhereInput): StudentSubscriptionPayload
  subject(where: SubjectSubscriptionWhereInput): SubjectSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type User {
  id: ID!
  username: String!
  email: String
  school: School
  phone: String
  password: String!
  role: Role!
  createdAt: DateTime
  updatedAt: DateTime
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  username: String!
  email: String
  school: SchoolCreateOneInput
  phone: String
  password: String!
  role: Role
}

input UserCreateOneInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  username_ASC
  username_DESC
  email_ASC
  email_DESC
  phone_ASC
  phone_DESC
  password_ASC
  password_DESC
  role_ASC
  role_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type UserPreviousValues {
  id: ID!
  username: String!
  email: String
  phone: String
  password: String!
  role: Role!
  createdAt: DateTime
  updatedAt: DateTime
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateDataInput {
  username: String
  email: String
  school: SchoolUpdateOneInput
  phone: String
  password: String
  role: Role
}

input UserUpdateInput {
  username: String
  email: String
  school: SchoolUpdateOneInput
  phone: String
  password: String
  role: Role
}

input UserUpdateManyMutationInput {
  username: String
  email: String
  phone: String
  password: String
  role: Role
}

input UserUpdateOneInput {
  create: UserCreateInput
  update: UserUpdateDataInput
  upsert: UserUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: UserWhereUniqueInput
}

input UserUpsertNestedInput {
  update: UserUpdateDataInput!
  create: UserCreateInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  username: String
  username_not: String
  username_in: [String!]
  username_not_in: [String!]
  username_lt: String
  username_lte: String
  username_gt: String
  username_gte: String
  username_contains: String
  username_not_contains: String
  username_starts_with: String
  username_not_starts_with: String
  username_ends_with: String
  username_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  school: SchoolWhereInput
  phone: String
  phone_not: String
  phone_in: [String!]
  phone_not_in: [String!]
  phone_lt: String
  phone_lte: String
  phone_gt: String
  phone_gte: String
  phone_contains: String
  phone_not_contains: String
  phone_starts_with: String
  phone_not_starts_with: String
  phone_ends_with: String
  phone_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  role: Role
  role_not: Role
  role_in: [Role!]
  role_not_in: [Role!]
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  email: String
  phone: String
}
`
      }
    